%% file header

% filename:     ecg_statistics
% author:       dominik limbach
% date:         25.03.18

% description:  
%               -load data
%               -extract variables
%               
%               
%               -save results      

% ########################################################################
% load results
% ########################################################################

clc;
clear;
close all;

% name list
subject_names = strings(1,10);
subject_names(1) = 'aliVR' ;
subject_names(2) = 'doroVR' ;
subject_names(3) = 'floVR' ;
subject_names(4) = 'frankVR' ;
subject_names(5) = 'gautamVR' ;
subject_names(6) = 'kimVR' ;
subject_names(7) = 'lucaVR' ;
subject_names(8) = 'manuelaVR' ;
subject_names(9) = 'shantanuVR' ;
subject_names(10) = 'silviaVR' ;
  
% file name
filepath = 'F:\GitHubRepositories\Work-\ClosedLoopVirtualRealityfortheTreatmentofPhobias\Matlab\StatisticsRawData\ECG\';
filetype = '.mat';
surname = 'ECG_';

% create cell to store the structures
res_ECG = cell(1,length(subject_names));
% fill the cell
for i = 1: length(subject_names)
name = subject_names(i);
file_name = strcat(filepath,surname,name,filetype);
res_ECG{i} = load(file_name);
end
% transform ro struct
res_ECG_mat = cell2mat(res_ECG);

% statistic variables 
bHR_mean = zeros(1,length(subject_names));
nHR_mean = zeros(1,length(subject_names));
bRR_min = zeros(1,length(subject_names));
nRR_min = zeros(1,length(subject_names));
bRR_max = zeros(1,length(subject_names));
nRR_max = zeros(1,length(subject_names));
bRR_delta = zeros(1,length(subject_names));
nRR_delta = zeros(1,length(subject_names));
nRR_mean = zeros(1,length(subject_names));
bRR_mean = zeros(1,length(subject_names));

bRMSSD = zeros(1,length(subject_names));
nRMSSD = zeros(1,length(subject_names));

% length of the longest P_int vector
bl = 495;
ba_RR_int = zeros(length(subject_names),bl);
% length of the longest P_int vector
nl = 868;
na_RR_int = zeros(length(subject_names),nl);

% extract variables

for i = 1:length(subject_names)
bHR_mean(i) = res_ECG_mat(i).bHR;
nHR_mean(i) = res_ECG_mat(i).nHR;
bRR_min(i) = 60./res_ECG_mat(i).bHR_max;
nRR_min(i) = 60./res_ECG_mat(i).nHR_max;
bRR_max(i) = 60./res_ECG_mat(i).bHR_min;
nRR_max(i) = 60./res_ECG_mat(i).bHR_min;
bRR_delta(i) = abs(bRR_max(i)-bRR_min(i));
nRR_delta(i) = abs(nRR_max(i)-nRR_min(i));
nRR_mean(i) = 60./res_ECG_mat(i).nHR;
bRR_mean(i) = 60./res_ECG_mat(i).bHR;

ba_RR_int(i,1:length(res_ECG_mat(i).bRR_int))=res_ECG_mat(i).bRR_int;
na_RR_int(i,1:length(res_ECG_mat(i).nRR_int))=res_ECG_mat(i).nRR_int;

%RMSSD
bRR_square = res_ECG_mat(i).bRR_int .^2;
bRR_square_avg = mean(bRR_square);
bRMSSD(i) = sqrt(bRR_square_avg);

nRR_square = res_ECG_mat(i).nRR_int .^2;
nRR_square_avg = mean(nRR_square);
nRMSSD(i) = sqrt(nRR_square_avg);

end

% ########################################################################
%statistics
% ########################################################################

% RR interval boxplot
% fill empty slots with NaN
ba_RR_int(ba_RR_int == 0) = NaN;
ba_RR_int = ba_RR_int';
% fill empty slots with NaN
na_RR_int(na_RR_int == 0) = NaN;
na_RR_int = na_RR_int';

% plot 

figure;
hold on;
title('RR interval distribution')
subplot(2,1,1);
boxplot(ba_RR_int);
grid on;
ylim([0.3 1.3]);
title('Baseline')
ylabel('RR interval [s]')

subplot(2,1,2); 
boxplot(na_RR_int);
grid on;
ylim([0.3 1.3]);
title('Exposure')
ylabel('RR interval [s]')
xlabel('Subject')
hold off;

s1 = 'RR interval distribution';
s3 = '_VR';
savename = strcat(s1,s3);
savefig([filepath filesep savename]);
saveas(gcf, [filepath filesep savename], 'png')

% test auf normalverteilung
% sharpiro wilk test

% own
% sample size
n = length(subject_names);
% sort the sample 
nsample_sort = sort(nRR_mean);
bsample_sort = sort(bRR_mean);

%calculate ss
nX = zeros(1,n);

for i = 1:n
    nX(i) =  (nsample_sort(i) - mean(nsample_sort)).^2;
end
nSS = sum(nX)/(n-1);

bX = zeros(1,n);
for i = 1:n
    bX(i) =  (bsample_sort(i) - mean(bsample_sort)).^2;
end
bSS = sum(bX)/(n-1);

% calculate m
if mod(n,2) == 0
    m = n/2;
else
    m = (n-1)/2;
end

% get koefficients from table for n 
% http://www.real-statistics.com/tests-normality-and-symmetry/statistical-tests-normality-symmetry/shapiro-wilk-test/
a_coe = [0.5739 0.3291 0.2141 0.1224 0.0399];
nY = zeros(1,m);
bY = zeros(1,m);
%calculate b
for i = 1:m
    nY(i) = a_coe(i)*(nsample_sort(n+1-i)-nsample_sort(i));
end
nb = sum(nY);

for i = 1:m
    bY(i) = a_coe(i)*(bsample_sort(n+1-i)-bsample_sort(i));
end
bb = sum(bY);

% calculate test statistics W
nd = nSS*(n-1);
bd = bSS*(n-1);
nW = nb.^2/nd;
bW = bb.^2/bd;

% the p-value has been taken from a table 
% for n = 10 and nW = 0.9650
np = 0.5;

% for n = 10 and bW = 0.9596
bp = 0.9;

% alpha = 0.05 and therfore from the table W critical = 0.842 for n = 10
W_crit = 0.842;

if nW >= W_crit
   % 0 Hypothesis confirmed the sample has a normal distribution
   nH = 0;
else
   % 0 Hypothesis rejected the sample has no normal distribution
   nH = 1;
end

if bW >= W_crit
   % 0 Hypothesis confirmed the sample has a normal distribution
   bH = 0;
else
   % 0 Hypothesis rejected the sample has no normal distribution
   bH = 1;
end

% Zweistichproben t test (abhängig)
% H0 hypothese ist das muD = 0 dh die differenz zwischen bl und exp = 0 ist
% H0 wird nur dann verworfen wenn die differenz deutlich größer als 0 ist
% wir testen also einseitig mit g-1 = 9 freiheitsgraden und alpha von 0.05
% und erhalten eine verwerfungsgrenze von 1.8331 
% d.h. wenn t >= 1.8331 ist wird H0 verworfen 

% verwerfungswert
v_out = 1.8331;
% test niveau
alpha = 0.05;

% angenommene Differenz
omega_0 = 0;

% anzahl der test paare
p = length(subject_names);

sample_exp = nRR_mean;
sample_bl = bRR_mean;

% differenz bilden , wir gehen davon aus dass die RR intervall der
% exposition kürzer sind als die der baseline
paar_diff =  sample_bl-sample_exp;

% calc avg diff
d = mean(paar_diff);
sd = zeros(1,p);

for i=1:p
sd(i) = (paar_diff(i) - d).^2;
end

ssd = sum(sd)/(p-1);

% t wert
t = (d - omega_0)/ sqrt(ssd/p);

if t >= v_out
    % wenn t größer ist als der verwurfswert dann is H0 widerlegt
    Ht = 1;
else
    % wenn t kleiner ist als der verwurfswert dann ist H0 bestätigt
    Ht = 0;
end

% bravais pearson cohens r

var_sample_exp = var(sample_exp);
var_sample_bl = var(sample_bl);

% d for same sample size but different sample variances
d = (mean(sample_bl)-mean(sample_exp))/ sqrt(var_sample)
